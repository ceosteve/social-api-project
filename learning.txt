CRUD based applications
Creat posts
Read posts
Update posts
Delete posts


conventions for creating a CRUD based API applications

CREAT   =  POST = @app.post("/posts)
READ    =  GET = @app.get("/post/{id})
        =  GET = @app.get("/posts)
UPDATE  =  PUT/PATCH = @app.put("/posts/{id}")
DELETE  =  DELETE = @app.delete("/posts/{id}")

>  When creating a path operation, it must have a decorator, in this case
   the decorator is an instance created globally using the FASTPI class of the 
   fastapi module.

>  The path operation must also contain a HTTP method to send a CRUD based request
   to the API server. 

>  The path operation should also specify a specific path on the URL, which will be used
   to locate a particular resource on the server and perform the HTTP request on it.

>  The path operation function specifies what the API will do when a specific request 
   is sent to the server

> The path operation fucntion is a decorator. Ideally, it adds behavior to the path operation 
  function without changing the function itself and then returns a new function, just the way it
  would work in a normal python script. 


DATABASE
a collection of organized data that can be easily accessed and managed
we dont directly interact with the database, rather we use a database management system as the link between 
us and the database

Relationsl databases
  1. MYSQL
  2.POSTGRESQL
  3.ORACLE
  4.SQL SERVER

NoSQL databases
  1. MongoDB
  2.DynamoDB
  3.ORACLE
  4. SQL SERVER

SQL = Structured query language, language used to communicate with a database management system
In POSTGRESQL, installing the DMS automatically creates one instance which is a databse called posgres
This database is necessary since Postgres needs a name of a database to connect to

Tables 
used for different kinds of data
in relational databases, these tables need to be designed in the database in such a manner that they have
a relationship with each other

Databases have datatypes
for Postgres, the datatypes include
Numeric -  int, decimal, precision
text - varchar, text
bool - boolean
sequence - array

One primary key has to be defined in a table
each entry has to be unique for the data we store in tables within a databse
as long as it can identify each entry uniquely

Unique Constraint can be added to a column to ensure that each entry is unique and that there are no duplicates
Null Constraint can be used to ensure that   Postgres does not use Null if a column is left blank. Rather, 
it is ging to throw an error


psycopg module is used to connect an API to a database.
psycopg.connnect - connect to a database
opening a cursor to perform operations on a database (conn.cursor())
can use the cursor.execute() method to query a database and obtain data as python objects

This is the method of writing API routes as SQL querries. But first, an API has to be connected to a database. 
Then SQL code can be written to query the database using CRUD operations (CREATE, READ, UDPDATE, DELETE)
Keep in mind that these queries still need to be sent to the server as HTTP requests therefore there is need to 
still maintain the path operations that give ports on a URL via which to execute the SQL query commands.
 
 After executing a put HTTP request, i.e, an UPDATE SQL query, those changes need to be committed permanently
 to the database. This is achieved by running a conn.commit() command.


 WORKING WITH A DATABASE WITHIN A PYTHON APPLICATION 

 An application can talk to a database using either a database driver like pgadmin in Postgres
 where SQL commands are sent directly to the database. 
 Alternatively, an ORM (OBJECT RELATIONAL MAPPER) can be used as a layer of abstraction between the database and the FASTAPI application
 Hence, database operations can be performed using traditional python code which will then be translated into SQL commands

The ORM takes our python code and translates it into SQL commands since SQL is the only language through which
applications can talk to databases. 
In that case, we only need to write standard python code and not necessarily write SQL commands directly into our application

Various ORMs exists 
SQLALCHEMY - standalone python library
can be used with other web frameworks or any python based applications

SQLALCHEMY still needs a database driver since it has no way to talk to a database
psycopg is a postgres database driver

SQLALCHEMY takes in python code and translates into SQL commands to be executed on a database
Have to define a models file with code to create a table and its columns
Have to define another file with teh name database to hold the code that will establish a connection to the 
database using SQLALCHEMY

A ORM basically abstracts SQL and allows us to perform SQL commands on a database in the form of regular python objects


SCHEMA (PYDANTIC MODEL)  VS SQLALCHEMY MODELS

> schema or pydantic models define how the data passed to the api server from ther client look like
> they also define how the response given from the api server to the client looks like
> defining the response that users get when they interact with the api server

>sqlalchemy models are responsible for defining the columns of posts
> using the model created, we can perform queries on the database


USER FUNCTIONALITY
Create an account
login
create posts associated with their specific account



When working with user information in databases, we should always hash passwords for security reasons
just in case user data gets leaked of the server/database gets leaked


PYDANTIC
data validation library used in python
With pydantic, one can serialize and deserialize pydantic objects as python dictionaries 
and JSON strings

PASSWORDS HASHING USING PASSLIB 0AUTH
> passwords need to always be hashed before being stored in a database to ensure that user data is safe in case a database gets hacked into
> it is good practice to seperate routes for posts or whatever else we may be dealing with, from the routes for handling users
> put the two into different files and use the APIRoutes class of fastapi to create a routes instance upon which paths will run


AUTHENTICATION (JWT TOKEN AUTHENTICATION)

> session based authentication- store a piece of information in the api server or database to indicate 
  whether a user is logged in or not
> JWT token based authentication - stateless- nothing on the backend to store info on the status of logged in
> The token is not stored on the backend but rather on the frontend, i.e, with the client, in this case, the browser

> the client provides their username and password, which will be matched against the ones stored in the database
> If the credentials are valid, the API provides a JWT token to the client 
> If a user wants to access resources on the database/server/ they have to passs the JWT token in the body of theur request
> The api will verify that the token is valid and if so, send back the information or data that has been requested by the user

> A JWT token contains three things
      HEADER
      PAYLOAD
      VERIFY SIGNATURE stores on the API
> a token will consist of the above three things. 
> the signature is created by taking the same header and payload in the body of the token, then combining them with a secret password that 
is only stored in the api
> the generated signature, together with the header and payload make up a token
> if a user changes data, say for example the payload, he can create a new token, but won't be able to create a signature since only the api server
can generate and store a secret password that forms part of the signature. 
> the new token will be sent to the API server and a test signature generated to check whether the signature matches the one that was generated when the token
was first created by the API server. If they do not match, then the user will be denied access to data.


VERIFYING USER CREDENTIALS AND CREATING JWTS

> user creates an account using the schema/pydantic model defined in the schemas file
> the user information gets stored in the database using sqlalchemy model defined using the Base class, and this was defined in the models file
> at login, the user provides their password, it will be hashed and compared to the hashed password stored in the database. If they match, user gets access to resource 
 specified in the path of their HTTP request
 > at login, if user credentials match the ones stored in the database, the API will generate a JWT, and the frontend will store it. 
 > so everytime the client sends a request, it attaches the JWT in the header of the request
 > fastapi uses helper functions to extract the token and validate it, then depending on the payload of the token, the api grants the user access to specific resources
 

 > relationships can be established between two data tables by adding an extra column that makes reference to a specific column in another table
 